<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ONS Chart</title>

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
      body { font-family: Arial, sans-serif; margin: 24px; }
      .wrap { max-width: 900px; margin: 0 auto; }
      .note { color: #444; }
      pre { background:#f6f6f6; padding:12px; overflow:auto; max-height:320px; }
      .small { font-size:0.9rem; color:#666; margin-top:6px; }
    </style>
  </head>

  <body>
    <div class="wrap">
      <h1>My ONS Chart</h1>
      <p class="note">If it says “Loaded points”, it worked.</p>

      <canvas id="chart" height="120"></canvas>
      <p id="status"></p>

      <h3>Raw response (first 2000 chars):</h3>
      <pre id="raw"></pre>
      <p class="small">Open the browser console for more detailed logs (why items were accepted/rejected).</p>
    </div>

    <script>
      const ONS_URL =
        "https://api.beta.ons.gov.uk/v1/datasets/cpih01/editions/time-series/versions/6/observations?time=*&geography=K02000001&aggregate=cpih1dim1A0";

      const statusEl = document.getElementById("status");
      const rawEl = document.getElementById("raw");

      function findObservations(root) {
        if (!root) return [];
        if (Array.isArray(root.observations)) return root.observations;
        if (Array.isArray(root.data?.observations)) return root.data.observations;
        if (Array.isArray(root.result?.observations)) return root.result.observations;
        if (Array.isArray(root.items)) return root.items;
        const maybeObs = root.observations ?? root.data?.observations ?? root.result?.observations ?? root.items;
        if (maybeObs && typeof maybeObs === 'object') return Object.values(maybeObs);
        return [];
      }

      // Basic month map for parsing labels like "May-04"
      const MONTHS = { jan:0, feb:1, mar:2, apr:3, may:4, jun:5, jul:6, aug:7, sep:8, sept:8, oct:9, nov:10, dec:11 };

      // Extract time label robustly, handling "Time" key and case variations
      function extractTimeLabel(o) {
        const dims = o.dimensions ?? o.dimension ?? {};
        // If dims is object keyed by name (case may vary), check keys case-insensitively
        if (!Array.isArray(dims) && typeof dims === 'object') {
          for (const key of Object.keys(dims)) {
            if (/^time$/i.test(key) || /^period$/i.test(key) || /^date$/i.test(key)) {
              const td = dims[key];
              if (td && (td.label || td.id)) return String(td.label ?? td.id);
            }
          }
          // Specific check for "Time" capitalised (observed in your sample)
          if (dims.Time && (dims.Time.label || dims.Time.id)) return String(dims.Time.label ?? dims.Time.id);
          // fallback: scan values for label/id that look date-like
          for (const v of Object.values(dims)) {
            if (v && (v.label || v.id)) {
              const s = String(v.label ?? v.id);
              if (/\b[A-Za-z]{3,9}[- ]\d{2,4}\b/.test(s) || /^\d{4}[-/]\d{2}/.test(s)) return s;
            }
          }
        }

        // If dims is an array, look for time-like items
        if (Array.isArray(dims)) {
          for (const d of dims) {
            if (!d || typeof d !== 'object') continue;
            if ((d.name && /time|period|date/i.test(d.name)) || (d.id && /time|period|date/i.test(d.id))) {
              return d.option?.label ?? d.option?.id ?? d.label ?? d.id ?? "";
            }
            const s = String(d.label ?? d.id ?? "");
            if (s && (/\b[A-Za-z]{3,9}[- ]\d{2,4}\b/.test(s) || /^\d{4}[-/]\d{2}/.test(s))) return s;
          }
        }

        // Top-level fallbacks
        for (const k of ['time','date','period']) {
          if (o[k]) return String(o[k]);
        }
        return "";
      }

      function extractValue(o) {
        const raw = o.observation ?? o.value ?? o.obs ?? o.datapoint ?? o.valueLabel;
        const num = Number(raw);
        return Number.isFinite(num) ? num : NaN;
      }

      // Try to parse label into timestamp for sorting; returns NaN if not a date
      function parseTimestamp(label) {
        if (typeof label !== 'string') return NaN;
        const s = label.trim();
        // match "May-04" etc.
        const m = s.match(/^([A-Za-z]{3,9})[- ](\d{2,4})$/);
        if (m) {
          const monthIdx = MONTHS[m[1].toLowerCase().slice(0,3)];
          if (monthIdx !== undefined) {
            let y = Number(m[2]);
            if (y < 100) y = y <= 49 ? 2000 + y : 1900 + y;
            return Date.UTC(y, monthIdx, 1);
          }
        }
        const iso = Date.parse(s);
        if (!Number.isNaN(iso)) return iso;
        const digits = s.match(/^(\d{4})(\d{2})?(\d{2})?$/);
        if (digits) {
          const y = Number(digits[1]), mm = Number(digits[2] ?? '01'), dd = Number(digits[3] ?? '01');
          return Date.UTC(y, mm - 1, dd);
        }
        return NaN;
      }

      async function run() {
        statusEl.textContent = "Loading data from ONS...";
        try {
          const res = await fetch(ONS_URL);
          if (!res.ok) throw new Error("ONS request failed: " + res.status + " " + res.statusText);
          const data = await res.json();
          rawEl.textContent = JSON.stringify(data, null, 2).slice(0, 2000);

          const obs = findObservations(data);
          console.log("Total observations found:", obs.length);
          if (!obs || obs.length === 0) {
            console.error("No observations found. Full JSON:", data);
            throw new Error("No observations returned. See console for the returned JSON.");
          }

          // Map and collect diagnostics
          const mapped = obs.map((o, idx) => {
            const x = extractTimeLabel(o);
            const y = extractValue(o);
            return { idx, x, y, raw: o };
          });

          const accepted = mapped.filter(m => m.x && Number.isFinite(m.y));
          const rejected = mapped.filter(m => !(m.x && Number.isFinite(m.y)));

          console.log("Accepted count:", accepted.length, "Rejected count:", rejected.length);
          if (rejected.length > 0) {
            console.log("First 6 rejected samples (idx,x,y,raw):", rejected.slice(0,6));
          }
          if (accepted.length > 0) {
            console.log("First 6 accepted samples (idx,x,y,raw):", accepted.slice(0,6));
          }

          if (accepted.length === 0) {
            console.error("Parsed points array is empty. Sample observation:", obs[0]);
            throw new Error("Parsed no valid (time,value) points from observations. Check console for diagnostics above.");
          }

          // build points, sort
          const points = accepted.map(a => ({ x: a.x, y: a.y }));
          points.sort((a, b) => {
            const ta = parseTimestamp(a.x);
            const tb = parseTimestamp(b.x);
            if (Number.isFinite(ta) && Number.isFinite(tb)) return ta - tb;
            return String(a.x).localeCompare(String(b.x));
          });

          // draw chart
          const canvas = document.getElementById("chart");
          const ctx = canvas.getContext("2d");
          if (window._onsChart instanceof Chart) {
            try { window._onsChart.destroy(); } catch (e) { /* ignore */ }
          }
          window._onsChart = new Chart(ctx, {
            type: "line",
            data: {
              labels: points.map(p => p.x),
              datasets: [{ label: "ONS value", data: points.map(p => p.y), borderColor: "rgba(33,150,243,1)", backgroundColor: "rgba(33,150,243,0.12)", fill: true }]
            },
            options: { responsive: true, interaction: { mode: "index", intersect: false } }
          });

          statusEl.textContent = "Loaded " + points.length + " points from ONS ✅";
        } catch (err) {
          console.error(err);
          statusEl.textContent = "Error: " + err.message;
        }
      }

      run();
    </script>
  </body>
</html>
