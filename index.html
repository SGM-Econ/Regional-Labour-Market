<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ONS Chart</title>

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
      body { font-family: Arial, sans-serif; margin: 24px; }
      .wrap { max-width: 900px; margin: 0 auto; }
      .note { color: #444; }
      pre { background:#f6f6f6; padding:12px; overflow:auto; max-height:320px; }
      .small { font-size:0.9rem; color:#666; margin-top:6px; }
    </style>
  </head>

  <body>
    <div class="wrap">
      <h1>My ONS Chart</h1>
      <p class="note">If it says “Loaded points”, it worked.</p>

      <canvas id="chart" height="120"></canvas>
      <p id="status"></p>

      <!-- Debug area (visible) to make it easy to inspect the raw response -->
      <h3>Raw response (first 2000 chars):</h3>
      <pre id="raw"></pre>
      <p class="small">Open the browser console for more detailed logs (sample observation, parsing problems, etc.).</p>
    </div>

    <script>
      // ONS API address
      const ONS_URL =
        "https://api.beta.ons.gov.uk/v1/datasets/cpih01/editions/time-series/versions/6/observations?time=*&geography=K02000001&aggregate=cpih1dim1A0";

      const statusEl = document.getElementById("status");
      const rawEl = document.getElementById("raw");

      // Robust getters for different shapes of the ONS response & observations
      function findObservations(root) {
        // Try a few common places the API might put observations
        if (!root) return [];
        if (Array.isArray(root.observations)) return root.observations;
        if (Array.isArray(root.data?.observations)) return root.data.observations;
        if (Array.isArray(root.result?.observations)) return root.result.observations;
        if (Array.isArray(root.items)) return root.items;
        // may be an object keyed by id -> observation
        const maybeObs = root.observations ?? root.data?.observations ?? root.result?.observations ?? root.items;
        if (maybeObs && typeof maybeObs === 'object') return Object.values(maybeObs);
        return [];
      }

      // Extract time label from an observation, handling dims as array or object
      function extractTimeLabel(o) {
        const dims = o.dimensions ?? o.dimension ?? {};
        let timeDim;

        if (Array.isArray(dims)) {
          timeDim = dims.find(d => d && (d.name === 'time' || d.id === 'time' || d.label === 'time'));
        } else {
          timeDim = dims.time || Object.values(dims || {}).find(d => d && (d.name === 'time' || d.id === 'time' || d.label === 'time'));
        }

        const candidates = [
          timeDim?.option?.label,
          timeDim?.option?.id,
          timeDim?.id,
          timeDim?.label,
          o.time,
          o.date,
          o.period,
          o.observation?.time
        ];

        for (const c of candidates) {
          if (c !== undefined && c !== null && String(c).trim() !== '') return String(c);
        }
        return "";
      }

      // Extract numeric value from an observation
      function extractValue(o) {
        const raw = o.observation ?? o.value ?? o.obs ?? o.datapoint ?? o.valueLabel;
        const num = Number(raw);
        return Number.isFinite(num) ? num : NaN;
      }

      // Try to parse a label into a timestamp (ms) for sorting; returns NaN if not a date
      function parseTimestamp(label) {
        // If label looks like YYYY or YYYY-Qn or YYYY-MM or YYYY-MM-DD, try some formats:
        if (typeof label !== 'string') return NaN;
        const s = label.trim();

        // Year-quarter like "2020 Q1" or "2020-Q1"
        const qmatch = s.match(/^(\d{4})\s*[- ]?Q?([1-4])$/i);
        if (qmatch) {
          const year = Number(qmatch[1]), q = Number(qmatch[2]);
          // approximate quarter start
          const month = (q - 1) * 3;
          return Date.UTC(year, month, 1);
        }

        // Year-month like "2020-04" or "2020/04" or "Apr 2020"
        const iso = Date.parse(s);
        if (!Number.isNaN(iso)) return iso;

        // fallback: try to coerce "YYYYMM" or "YYYYMMDD"
        const digits = s.match(/^(\d{4})(\d{2})?(\d{2})?$/);
        if (digits) {
          const y = Number(digits[1]), m = Number(digits[2] ?? '01'), d = Number(digits[3] ?? '01');
          return Date.UTC(y, m - 1, d);
        }

        return NaN;
      }

      async function run() {
        statusEl.textContent = "Loading data from ONS...";
        try {
          const res = await fetch(ONS_URL);

          if (!res.ok) {
            throw new Error("ONS request failed: " + res.status + " " + res.statusText);
          }

          const data = await res.json();

          // Show a short preview of the raw response for debugging
          rawEl.textContent = JSON.stringify(data, null, 2).slice(0, 2000);

          const obs = findObservations(data);

          if (!obs || obs.length === 0) {
            console.error("No observations found in response. Full JSON:", data);
            throw new Error("No observations returned. The API response structure may differ from expectations. See console for the returned JSON.");
          }

          console.log("Sample observation (obs[0]):", obs[0]);

          // Map observations into points with robust extractors
          const points = obs
            .map(o => {
              const x = extractTimeLabel(o);
              const y = extractValue(o);
              return { x, y, raw: o };
            })
            .filter(p => p.x && Number.isFinite(p.y));

          if (points.length === 0) {
            console.error("Parsed points array is empty. Sample obs[0]:", obs[0]);
            throw new Error("Parsed no valid (time,value) points from observations. Check the response shape in the console.");
          }

          // Sort points: prefer chronological if labels parse as dates, otherwise lexicographic
          points.sort((a, b) => {
            const ta = parseTimestamp(a.x);
            const tb = parseTimestamp(b.x);
            if (Number.isFinite(ta) && Number.isFinite(tb)) return ta - tb;
            return a.x.localeCompare(b.x);
          });

          // Draw the chart (use 2D context)
          const canvas = document.getElementById("chart");
          const ctx = canvas.getContext("2d");

          // Destroy previous chart if re-running in same page (safety)
          if (window._onsChart instanceof Chart) {
            try { window._onsChart.destroy(); } catch (e) { /* ignore */ }
          }

          window._onsChart = new Chart(ctx, {
            type: "line",
            data: {
              labels: points.map(p => p.x),
              datasets: [
                {
                  label: "ONS value",
                  data: points.map(p => p.y),
                  borderColor: "rgba(33, 150, 243, 1)",
                  backgroundColor: "rgba(33, 150, 243, 0.12)",
                  tension: 0.15,
                  fill: true,
                  pointRadius: 2
                }
              ]
            },
            options: {
              responsive: true,
              interaction: { mode: "index", intersect: false },
              scales: {
                x: { display: true, title: { display: true, text: "Time" } },
                y: { display: true, title: { display: true, text: "Value" } }
              }
            }
          });

          statusEl.textContent = "Loaded " + points.length + " points from ONS ✅";
        } catch (err) {
          console.error(err);
          statusEl.textContent = "Error: " + err.message;
        }
      }

      // Run the loader
      run();
    </script>
  </body>
</html>
